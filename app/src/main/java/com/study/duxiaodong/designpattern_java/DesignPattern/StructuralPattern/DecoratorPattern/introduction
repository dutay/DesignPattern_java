1. 含义
    装饰模式，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
    即调用者从外部传入的被装饰对象，对被装饰对象进行装饰


2. 具体结构
     1.Component：对象接口，也可以是一个抽象类，是被装饰类和装饰类的基本类型，可以给这些对象动态地添加职责。

     2.ConcreteComponent：被装饰类，Component的实现类，是要被进行修饰的对象，也可以给这个对象动态地添加职责。可以有多个。

     3.Decorator：装饰类，是一个抽象类，实现了Component，同时，在内部维护了一个ConcreteComponent的实例，可以通过构造函数进行初始化。在其内部只是声明了一个个装饰的方法，具体实现由其子类去实现。

     4.ConcreteDecoratorA/ConcreteDecoratorB：具体的装饰产品类，继承了Decorator，其中可以通过构造器声明装饰哪种类型的ConcreteComponent。还包括装饰的具体实现方法，起到了给Component添加职责的功能。



3. 优点
    1.装饰类和被装饰类可以独立发展，而不会相互耦合
    2.装饰模式是继承关系的一个替代方案，不管装饰多少层，他始终是一个Component，
      实现的还是is-a的关系,所以他是继承的一种良好替代方案

4. 缺点
    1.多层的装饰是比较复杂,比如查找问题时,被层层嵌套,不容易发现问题所在
5. 应用场景
    1.当你想要给一个类增加功能,然而,却并不想修改原来类的代码时,可以考虑装饰器模式如果你想要动态的给一个类增加功能,
      并且这个功能你还希望可以动态的撤销,就好像直接拿掉了一层装饰物




